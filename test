                
                game:GetService("Players").LocalPlayer.Idled:connect(function()
                    game:GetService("VirtualUser"):Button2Down(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
                    wait(1)
                    game:GetService("VirtualUser"):Button2Up(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
                end)
            
                _G.Color = Color3.fromRGB(255,0,0)
                if not game:IsLoaded() then repeat game.Loaded:Wait() until game:IsLoaded() end
                
                repeat wait() until game:GetService("Players")
                
                if not game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then repeat wait() until game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart") end
                    
                wait(1)
                
                do
                    local ui = game.CoreGui:FindFirstChild("PadoUi")
                    if ui then
                        ui:Destroy()
                    end
                end
                
                local UserInputService = game:GetService("UserInputService")
                local TweenService = game:GetService("TweenService")
                
                local function MakeDraggable(topbarobject, object)
                    local Dragging = nil
                    local DragInput = nil
                    local DragStart = nil
                    local StartPosition = nil
                
                    local function Update(input)
                        local Delta = input.Position - DragStart
                        local pos =
                            UDim2.new(
                                StartPosition.X.Scale,
                                StartPosition.X.Offset + Delta.X,
                                StartPosition.Y.Scale,
                                StartPosition.Y.Offset + Delta.Y
                            )
                        local Tween = TweenService:Create(object, TweenInfo.new(0.2), {Position = pos})
                        Tween:Play()
                    end
                
                    topbarobject.InputBegan:Connect(
                        function(input)
                            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                                Dragging = true
                                DragStart = input.Position
                                StartPosition = object.Position
                
                                input.Changed:Connect(
                                    function()
                                        if input.UserInputState == Enum.UserInputState.End then
                                            Dragging = false
                                        end
                                    end
                                )
                            end
                        end
                    )
                
                    topbarobject.InputChanged:Connect(
                        function(input)
                            if
                                input.UserInputType == Enum.UserInputType.MouseMovement or
                                input.UserInputType == Enum.UserInputType.Touch
                            then
                                DragInput = input
                            end
                        end
                    )
                
                    UserInputService.InputChanged:Connect(
                        function(input)
                            if input == DragInput and Dragging then
                                Update(input)
                            end
                        end
                    )
                end
                
                local library = {}
                
                function library:Window(text,keybind)

                    local bind = keybind or Enum.KeyCode.RightControl
                    local ff = false
                    local currenttab = ""
                
                    local DoctorShiba = Instance.new("ScreenGui")
                    DoctorShiba.Name = "PadoUi"
                    DoctorShiba.Parent = game.CoreGui
                    DoctorShiba.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
                
                    local Main = Instance.new("Frame")
                    Main.Name = "Main"
                    Main.Parent = DoctorShiba
                    Main.AnchorPoint = Vector2.new(0.5, 0.5)
                    Main.BackgroundColor3 = Color3.fromRGB(30, 28, 39)
                    Main.BackgroundTransparency = 0.100
                    Main.BorderSizePixel = 0
                    Main.ClipsDescendants = true
                    Main.Position = UDim2.new(0.499526083, 0, 0.499241292, 0)
                    Main.Size = UDim2.new(0, 600, 0, 350)
                
                    local Top = Instance.new("Frame")
                    Top.Name = "Top"
                    Top.Parent = Main
                    Top.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                    Top.BackgroundTransparency = 1.000
                    Top.BorderSizePixel = 0
                    Top.Size = UDim2.new(0, 600, 0, 20)
                
                    local Page = Instance.new("Frame")
                    Page.Name = "Page"
                    Page.Parent = Main
                    Page.BackgroundColor3 = Color3.fromRGB(25, 23, 35)
                    Page.BackgroundTransparency = 0.100
                    Page.BorderSizePixel = 0
                    Page.Size = UDim2.new(0, 125, 0, 350)
                
                    local NameHub = Instance.new("TextLabel")
                    NameHub.Name = "NameHub"
                    NameHub.Parent = Page
                    NameHub.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                    NameHub.BackgroundTransparency = 1.000
                    NameHub.Position = UDim2.new(0.113333493, 0, 0, 0)
                    NameHub.Size = UDim2.new(0, 110, 0, 20)
                    NameHub.Font = Enum.Font.GothamSemibold
                    NameHub.Text = text
                    NameHub.TextColor3 = Color3.fromRGB(225, 0, 0)
                    NameHub.TextSize = 11.000
                    NameHub.TextXAlignment = Enum.TextXAlignment.Left
                
                    local User = Instance.new("Frame")
                    User.Name = "User"
                    User.Parent = Page
                    User.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                    User.BackgroundTransparency = 1.000
                    User.Position = UDim2.new(0, 0, 0.8, 30)
                    User.Size = UDim2.new(0, 125, 0, 40)
                
                    local UserText = Instance.new("TextLabel")
                    UserText.Name = "UserText"
                    UserText.Parent = User
                    UserText.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                    UserText.BackgroundTransparency = 1.000
                    UserText.Position = UDim2.new(0.354999989, 0, 0, 11)
                    UserText.Size = UDim2.new(0, 80, 0, 20)
                    UserText.Font = Enum.Font.Gotham
                    UserText.Text = tostring(game.Players.LocalPlayer.Name) 
                    spawn(function()
                        while wait() do
                            pcall(function()
                                wait(0.1) 
                                game:GetService('TweenService'):Create(
                                    UserText,TweenInfo.new(1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut),
                                    {TextColor3 = Color3.fromRGB(255, 0, 0)}
                                ):Play() 
                                wait(.5)            
                                game:GetService('TweenService'):Create(
                                    UserText,TweenInfo.new(1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut),
                                    {TextColor3 = Color3.fromRGB(255, 155, 0)}
                                ):Play() 
                                wait(.5)            
                                game:GetService('TweenService'):Create(
                                    UserText,TweenInfo.new(1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut),
                                    {TextColor3 = Color3.fromRGB(255, 255, 0)}
                                ):Play() 
                                wait(.5)            
                                game:GetService('TweenService'):Create(
                                    UserText,TweenInfo.new(1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut),
                                    {TextColor3 = Color3.fromRGB(0, 255, 0)}
                                ):Play() 
                                wait(.5)            
                                game:GetService('TweenService'):Create(
                                    UserText,TweenInfo.new(1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut),
                                    {TextColor3 = Color3.fromRGB(0, 255, 255)}
                                ):Play() 
                                wait(.5)            
                                game:GetService('TweenService'):Create(
                                    UserText,TweenInfo.new(1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut),
                                    {TextColor3 = Color3.fromRGB(0, 155, 255)}
                                ):Play() 
                                wait(.5)            
                                game:GetService('TweenService'):Create(
                                    UserText,TweenInfo.new(1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut),
                                    {TextColor3 = Color3.fromRGB(255, 0, 255)}
                                ):Play() 
                                wait(.5)            
                                game:GetService('TweenService'):Create(
                                    UserText,TweenInfo.new(1,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut),
                                    {TextColor3 = Color3.fromRGB(255, 0, 155)}
                                ):Play() 
                                wait(.5)
                            end)
                        end
                    end)
                    UserText.TextScaled = true
                    UserText.TextSize = 11.000
                    UserText.TextWrapped = true
                    UserText.TextXAlignment = Enum.TextXAlignment.Left
                
                    local UITextSizeConstraint = Instance.new("UITextSizeConstraint")
                    UITextSizeConstraint.Parent = UserText
                    UITextSizeConstraint.MaxTextSize = 11
                
                    local UserImage = Instance.new("ImageLabel")
                    UserImage.Name = "UserImage"
                    UserImage.Parent = User
                    UserImage.BackgroundColor3 = Color3.fromRGB(225, 225, 225)
                    UserImage.Position = UDim2.new(0, 10, 0, 9)
                    UserImage.Size = UDim2.new(0, 25, 0, 25)
                    UserImage.Image = "https://www.roblox.com/headshot-thumbnail/image?userId="..game.Players.LocalPlayer.UserId.."&width=420&height=420&format=png"
                
                    local UserImageCorner = Instance.new("UICorner")
                    UserImageCorner.CornerRadius = UDim.new(0, 100)
                    UserImageCorner.Name = "UserImageCorner"
                    UserImageCorner.Parent = UserImage
                
                    local ScrollPage = Instance.new("ScrollingFrame")
                    ScrollPage.Name = "ScrollPage"
                    ScrollPage.Parent = Page
                    ScrollPage.Active = true
                    ScrollPage.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                    ScrollPage.BackgroundTransparency = 1.000
                    ScrollPage.BorderSizePixel = 0
                    ScrollPage.Position = UDim2.new(0, 0, 0.086, 0)
                    ScrollPage.Size = UDim2.new(0, 125, 0, 290)
                    ScrollPage.CanvasSize = UDim2.new(0, 0, 0, 0)
                    ScrollPage.ScrollBarThickness = 0
                    local PageList = Instance.new("UIListLayout")
                    PageList.Name = "PageList"
                    PageList.Parent = ScrollPage
                    PageList.SortOrder = Enum.SortOrder.LayoutOrder
                    PageList.Padding = UDim.new(0, 7)
                
                    local PagePadding = Instance.new("UIPadding")
                    PagePadding.Name = "PagePadding"
                    PagePadding.Parent = ScrollPage
                    PagePadding.PaddingTop = UDim.new(0, 5)
                    PagePadding.PaddingLeft = UDim.new(0, 28)
                
                    local TabFolder = Instance.new("Folder")
                    TabFolder.Name = "TabFolder"
                    TabFolder.Parent = Main
                
                    MakeDraggable(Top,Main)
                
                    local uihide = false
                
                    UserInputService.InputBegan:Connect(function(input)
                        if input.KeyCode == bind then
                            if uihide == false then
                                uihide = true
                                Main:TweenSize(UDim2.new(0, 0, 0, 0),"In","Quad",0.2,true)
                            else
                                uihide = false
                                Main:TweenSize(UDim2.new(0, 600, 0, 350),"Out","Quad",0.2,true)
                            end
                        end
                    end)

              local passes, fails, undefined = 0, 0, 0
              local running = 0
              
              local function getGlobal(path)
              	local value = getfenv(0)
              
              	while value ~= nil and path ~= "" do
              		local name, nextValue = string.match(path, "^([^.]+)%.?(.*)$")
              		value = value[name]
              		path = nextValue
              	end
              
              	return value
              end
              
              local function test(name, aliases, callback)
              	running += 1
              
              	task.spawn(function()
              		if not callback then
              		elseif not getGlobal(name) then
              			fails += 1
              		else
              			local success, message = pcall(callback)
              	
              			if success then
              				passes += 1
              			else
              				fails += 1
              			end
              		end
              	
              		local undefinedAliases = {}
              	
              		for _, alias in ipairs(aliases) do
              			if getGlobal(alias) == nil then
              				table.insert(undefinedAliases, alias)
              			end
              		end
              	
              		if #undefinedAliases > 0 then
              			undefined += 1
              			warn("⚠️ " .. table.concat(undefinedAliases, ", "))
              		end
              
              		running -= 1
              	end)
              end
              
              -- Header and summary
              
              
              -- Cache
              
              test("cache.invalidate", {}, function()
              	local container = Instance.new("Folder")
              	local part = Instance.new("Part", container)
              	cache.invalidate(container:FindFirstChild("Part"))
              	assert(part ~= container:FindFirstChild("Part"), "Reference `part` could not be invalidated")
              end)
              
              test("cache.iscached", {}, function()
              	local part = Instance.new("Part")
              	assert(cache.iscached(part), "Part should be cached")
              	cache.invalidate(part)
              	assert(not cache.iscached(part), "Part should not be cached")
              end)
              
              test("cache.replace", {}, function()
              	local part = Instance.new("Part")
              	local fire = Instance.new("Fire")
              	cache.replace(part, fire)
              	assert(part ~= fire, "Part was not replaced with Fire")
              end)
              
              test("cloneref", {}, function()
              	local part = Instance.new("Part")
              	local clone = cloneref(part)
              	assert(part ~= clone, "Clone should not be equal to original")
              	clone.Name = "Test"
              	assert(part.Name == "Test", "Clone should have updated the original")
              end)
              
              test("compareinstances", {}, function()
              	local part = Instance.new("Part")
              	local clone = cloneref(part)
              	assert(part ~= clone, "Clone should not be equal to original")
              	assert(compareinstances(part, clone), "Clone should be equal to original when using compareinstances()")
              end)
              
              -- Closures
              
              local function shallowEqual(t1, t2)
              	if t1 == t2 then
              		return true
              	end
              
              	local UNIQUE_TYPES = {
              		["function"] = true,
              		["table"] = true,
              		["userdata"] = true,
              		["thread"] = true,
              	}
              
              	for k, v in pairs(t1) do
              		if UNIQUE_TYPES[type(v)] then
              			if type(t2[k]) ~= type(v) then
              				return false
              			end
              		elseif t2[k] ~= v then
              			return false
              		end
              	end
              
              	for k, v in pairs(t2) do
              		if UNIQUE_TYPES[type(v)] then
              			if type(t2[k]) ~= type(v) then
              				return false
              			end
              		elseif t1[k] ~= v then
              			return false
              		end
              	end
              
              	return true
              end
              
              test("checkcaller", {}, function()
              	assert(checkcaller(), "Main scope should return true")
              end)
              
              test("clonefunction", {}, function()
              	local function test()
              		return "success"
              	end
              	local copy = clonefunction(test)
              	assert(test() == copy(), "The clone should return the same value as the original")
              	assert(test ~= copy, "The clone should not be equal to the original")
              end)
              
              test("getcallingscript", {})
              
              test("getscriptclosure", {"getscriptfunction"}, function()
              	local module = game:GetService("CoreGui").RobloxGui.Modules.Common.Constants
              	local constants = getrenv().require(module)
              	local generated = getscriptclosure(module)()
              	assert(constants ~= generated, "Generated module should not match the original")
              	assert(shallowEqual(constants, generated), "Generated constant table should be shallow equal to the original")
              end)
              
              test("hookfunction", {"replaceclosure"}, function()
              	local function test()
              		return true
              	end
              	local ref = hookfunction(test, function()
              		return false
              	end)
              	assert(test() == false, "Function should return false")
              	assert(ref() == true, "Original function should return true")
              	assert(test ~= ref, "Original function should not be same as the reference")
              end)
              
              test("iscclosure", {}, function()
              	assert(iscclosure(print) == true, "Function 'print' should be a C closure")
              	assert(iscclosure(function() end) == false, "Executor function should not be a C closure")
              end)
              
              test("islclosure", {}, function()
              	assert(islclosure(print) == false, "Function 'print' should not be a Lua closure")
              	assert(islclosure(function() end) == true, "Executor function should be a Lua closure")
              end)
              
              test("isexecutorclosure", {"checkclosure", "isourclosure"}, function()
              	assert(isexecutorclosure(isexecutorclosure) == true, "Did not return true for an executor global")
              	assert(isexecutorclosure(newcclosure(function() end)) == true, "Did not return true for an executor C closure")
              	assert(isexecutorclosure(function() end) == true, "Did not return true for an executor Luau closure")
              	assert(isexecutorclosure(print) == false, "Did not return false for a Roblox global")
              end)
              
              test("loadstring", {}, function()
              	local animate = game:GetService("Players").LocalPlayer.Character.Animate
              	local bytecode = getscriptbytecode(animate)
              	local func = loadstring(bytecode)
              	assert(type(func) ~= "function", "Luau bytecode should not be loadable!")
              	assert(assert(loadstring("return ... + 1"))(1) == 2, "Failed to do simple math")
              	assert(type(select(2, loadstring("f"))) == "string", "Loadstring did not return anything for a compiler error")
              end)
              
              test("newcclosure", {}, function()
              	local function test()
              		return true
              	end
              	local testC = newcclosure(test)
              	assert(test() == testC(), "New C closure should return the same value as the original")
              	assert(test ~= testC, "New C closure should not be same as the original")
              	assert(iscclosure(testC), "New C closure should be a C closure")
              end)
              
              -- Console
              
              test("rconsoleclear", {"consoleclear"})
              
              test("rconsolecreate", {"consolecreate"})
              
              test("rconsoledestroy", {"consoledestroy"})
              
              test("rconsoleinput", {"consoleinput"})
              
              test("rconsoleprint", {"consoleprint"})
              
              test("rconsolesettitle", {"rconsolename", "consolesettitle"})
              
              -- Crypt
              
              test("crypt.base64encode", {"crypt.base64.encode", "crypt.base64_encode", "base64.encode", "base64_encode"}, function()
              	assert(crypt.base64encode("test") == "dGVzdA==", "Base64 encoding failed")
              end)
              
              test("crypt.base64decode", {"crypt.base64.decode", "crypt.base64_decode", "base64.decode", "base64_decode"}, function()
              	assert(crypt.base64decode("dGVzdA==") == "test", "Base64 decoding failed")
              end)
              
              test("crypt.encrypt", {}, function()
              	local key = crypt.generatekey()
              	local encrypted, iv = crypt.encrypt("test", key, nil, "CBC")
              	assert(iv, "crypt.encrypt should return an IV")
              	local decrypted = crypt.decrypt(encrypted, key, iv, "CBC")
              	assert(decrypted == "test", "Failed to decrypt raw string from encrypted data")
              end)
              
              test("crypt.decrypt", {}, function()
              	local key, iv = crypt.generatekey(), crypt.generatekey()
              	local encrypted = crypt.encrypt("test", key, iv, "CBC")
              	local decrypted = crypt.decrypt(encrypted, key, iv, "CBC")
              	assert(decrypted == "test", "Failed to decrypt raw string from encrypted data")
              end)
              
              test("crypt.generatebytes", {}, function()
              	local size = math.random(10, 100)
              	local bytes = crypt.generatebytes(size)
              	assert(#crypt.base64decode(bytes) == size, "The decoded result should be " .. size .. " bytes long (got " .. #crypt.base64decode(bytes) .. " decoded, " .. #bytes .. " raw)")
              end)
              
              test("crypt.generatekey", {}, function()
              	local key = crypt.generatekey()
              	assert(#crypt.base64decode(key) == 32, "Generated key should be 32 bytes long when decoded")
              end)
              
              test("crypt.hash", {}, function()
              	local algorithms = {'sha1', 'sha384', 'sha512', 'md5', 'sha256', 'sha3-224', 'sha3-256', 'sha3-512'}
              	for _, algorithm in ipairs(algorithms) do
              		local hash = crypt.hash("test", algorithm)
              		assert(hash, "crypt.hash on algorithm '" .. algorithm .. "' should return a hash")
              	end
              end)
              
              --- Debug
              
              test("debug.getconstant", {}, function()
              	local function test()
              		print("Hello, world!")
              	end
              	assert(debug.getconstant(test, 1) == "print", "First constant must be print")
              	assert(debug.getconstant(test, 2) == nil, "Second constant must be nil")
              	assert(debug.getconstant(test, 3) == "Hello, world!", "Third constant must be 'Hello, world!'")
              end)
              
              test("debug.getconstants", {}, function()
              	local function test()
              		local num = 5000 .. 50000
              		print("Hello, world!", num, warn)
              	end
              	local constants = debug.getconstants(test)
              	assert(constants[1] == 50000, "First constant must be 50000")
              	assert(constants[2] == "print", "Second constant must be print")
              	assert(constants[3] == nil, "Third constant must be nil")
              	assert(constants[4] == "Hello, world!", "Fourth constant must be 'Hello, world!'")
              	assert(constants[5] == "warn", "Fifth constant must be warn")
              end)
              
              test("debug.getinfo", {}, function()
              	local types = {
              		source = "string",
              		short_src = "string",
              		func = "function",
              		what = "string",
              		currentline = "number",
              		name = "string",
              		nups = "number",
              		numparams = "number",
              		is_vararg = "number",
              	}
              	local function test(...)
              		print(...)
              	end
              	local info = debug.getinfo(test)
              	for k, v in pairs(types) do
              		assert(info[k] ~= nil, "Did not return a table with a '" .. k .. "' field")
              		assert(type(info[k]) == v, "Did not return a table with " .. k .. " as a " .. v .. " (got " .. type(info[k]) .. ")")
              	end
              end)
              
              test("debug.getproto", {}, function()
              	local function test()
              		local function proto()
              			return true
              		end
              	end
              	local proto = debug.getproto(test, 1, true)[1]
              	local realproto = debug.getproto(test, 1)
              	assert(proto, "Failed to get the inner function")
              	assert(proto() == true, "The inner function did not return anything")
              	if not realproto() then
              		return "Proto return values are disabled on this executor"
              	end
              end)
              
              test("debug.getprotos", {}, function()
              	local function test()
              		local function _1()
              			return true
              		end
              		local function _2()
              			return true
              		end
              		local function _3()
              			return true
              		end
              	end
              	for i in ipairs(debug.getprotos(test)) do
              		local proto = debug.getproto(test, i, true)[1]
              		local realproto = debug.getproto(test, i)
              		assert(proto(), "Failed to get inner function " .. i)
              		if not realproto() then
              			return "Proto return values are disabled on this executor"
              		end
              	end
              end)
              
              test("debug.getstack", {}, function()
              	local _ = "a" .. "b"
              	assert(debug.getstack(1, 1) == "ab", "The first item in the stack should be 'ab'")
              	assert(debug.getstack(1)[1] == "ab", "The first item in the stack table should be 'ab'")
              end)
              
              test("debug.getupvalue", {}, function()
              	local upvalue = function() end
              	local function test()
              		print(upvalue)
              	end
              	assert(debug.getupvalue(test, 1) == upvalue, "Unexpected value returned from debug.getupvalue")
              end)
              
              test("debug.getupvalues", {}, function()
              	local upvalue = function() end
              	local function test()
              		print(upvalue)
              	end
              	local upvalues = debug.getupvalues(test)
              	assert(upvalues[1] == upvalue, "Unexpected value returned from debug.getupvalues")
              end)
              
              test("debug.setconstant", {}, function()
              	local function test()
              		return "fail"
              	end
              	debug.setconstant(test, 1, "success")
              	assert(test() == "success", "debug.setconstant did not set the first constant")
              end)
              
              test("debug.setstack", {}, function()
              	local function test()
              		return "fail", debug.setstack(1, 1, "success")
              	end
              	assert(test() == "success", "debug.setstack did not set the first stack item")
              end)
              
              test("debug.setupvalue", {}, function()
              	local function upvalue()
              		return "fail"
              	end
              	local function test()
              		return upvalue()
              	end
              	debug.setupvalue(test, 1, function()
              		return "success"
              	end)
              	assert(test() == "success", "debug.setupvalue did not set the first upvalue")
              end)
              
              -- Filesystem
              
              if isfolder and makefolder and delfolder then
              	if isfolder(".tests") then
              		delfolder(".tests")
              	end
              	makefolder(".tests")
              end
              
              test("readfile", {}, function()
              	writefile(".tests/readfile.txt", "success")
              	assert(readfile(".tests/readfile.txt") == "success", "Did not return the contents of the file")
              end)
              
              test("listfiles", {}, function()
              	makefolder(".tests/listfiles")
              	writefile(".tests/listfiles/test_1.txt", "success")
              	writefile(".tests/listfiles/test_2.txt", "success")
              	local files = listfiles(".tests/listfiles")
              	assert(#files == 2, "Did not return the correct number of files")
              	assert(isfile(files[1]), "Did not return a file path")
              	assert(readfile(files[1]) == "success", "Did not return the correct files")
              	makefolder(".tests/listfiles_2")
              	makefolder(".tests/listfiles_2/test_1")
              	makefolder(".tests/listfiles_2/test_2")
              	local folders = listfiles(".tests/listfiles_2")
              	assert(#folders == 2, "Did not return the correct number of folders")
              	assert(isfolder(folders[1]), "Did not return a folder path")
              end)
              
              test("writefile", {}, function()
              	writefile(".tests/writefile.txt", "success")
              	assert(readfile(".tests/writefile.txt") == "success", "Did not write the file")
              	local requiresFileExt = pcall(function()
              		writefile(".tests/writefile", "success")
              		assert(isfile(".tests/writefile.txt"))
              	end)
              	if not requiresFileExt then
              		return "This executor requires a file extension in writefile"
              	end
              end)
              
              test("makefolder", {}, function()
              	makefolder(".tests/makefolder")
              	assert(isfolder(".tests/makefolder"), "Did not create the folder")
              end)
              
              test("appendfile", {}, function()
              	writefile(".tests/appendfile.txt", "su")
              	appendfile(".tests/appendfile.txt", "cce")
              	appendfile(".tests/appendfile.txt", "ss")
              	assert(readfile(".tests/appendfile.txt") == "success", "Did not append the file")
              end)
              
              test("isfile", {}, function()
              	writefile(".tests/isfile.txt", "success")
              	assert(isfile(".tests/isfile.txt") == true, "Did not return true for a file")
              	assert(isfile(".tests") == false, "Did not return false for a folder")
              	assert(isfile(".tests/doesnotexist.exe") == false, "Did not return false for a nonexistent path (got " .. tostring(isfile(".tests/doesnotexist.exe")) .. ")")
              end)
              
              test("isfolder", {}, function()
              	assert(isfolder(".tests") == true, "Did not return false for a folder")
              	assert(isfolder(".tests/doesnotexist.exe") == false, "Did not return false for a nonexistent path (got " .. tostring(isfolder(".tests/doesnotexist.exe")) .. ")")
              end)
              
              test("delfolder", {}, function()
              	makefolder(".tests/delfolder")
              	delfolder(".tests/delfolder")
              	assert(isfolder(".tests/delfolder") == false, "Failed to delete folder (isfolder = " .. tostring(isfolder(".tests/delfolder")) .. ")")
              end)
              
              test("delfile", {}, function()
              	writefile(".tests/delfile.txt", "Hello, world!")
              	delfile(".tests/delfile.txt")
              	assert(isfile(".tests/delfile.txt") == false, "Failed to delete file (isfile = " .. tostring(isfile(".tests/delfile.txt")) .. ")")
              end)
              
              test("loadfile", {}, function()
              	writefile(".tests/loadfile.txt", "return ... + 1")
              	assert(assert(loadfile(".tests/loadfile.txt"))(1) == 2, "Failed to load a file with arguments")
              	writefile(".tests/loadfile.txt", "f")
              	local callback, err = loadfile(".tests/loadfile.txt")
              	assert(err and not callback, "Did not return an error message for a compiler error")
              end)
              
              test("dofile", {})
              
              -- Input
              
              test("isrbxactive", {"isgameactive"}, function()
              	assert(type(isrbxactive()) == "boolean", "Did not return a boolean value")
              end)
              
              test("mouse1click", {})
              
              test("mouse1press", {})
              
              test("mouse1release", {})
              
              test("mouse2click", {})
              
              test("mouse2press", {})
              
              test("mouse2release", {})
              
              test("mousemoveabs", {})
              
              test("mousemoverel", {})
              
              test("mousescroll", {})
              
              -- Instances
              
              test("fireclickdetector", {}, function()
              	local detector = Instance.new("ClickDetector")
              	fireclickdetector(detector, 50, "MouseHoverEnter")
              end)
              
              test("getcallbackvalue", {}, function()
              	local bindable = Instance.new("BindableFunction")
              	local function test()
              	end
              	bindable.OnInvoke = test
              	assert(getcallbackvalue(bindable, "OnInvoke") == test, "Did not return the correct value")
              end)
              
              test("getconnections", {}, function()
              	local types = {
              		Enabled = "boolean",
              		ForeignState = "boolean",
              		LuaConnection = "boolean",
              		Function = "function",
              		Thread = "thread",
              		Fire = "function",
              		Defer = "function",
              		Disconnect = "function",
              		Disable = "function",
              		Enable = "function",
              	}
              	local bindable = Instance.new("BindableEvent")
              	bindable.Event:Connect(function() end)
              	local connection = getconnections(bindable.Event)[1]
              	for k, v in pairs(types) do
              		assert(connection[k] ~= nil, "Did not return a table with a '" .. k .. "' field")
              		assert(type(connection[k]) == v, "Did not return a table with " .. k .. " as a " .. v .. " (got " .. type(connection[k]) .. ")")
              	end
              end)
              
              test("getcustomasset", {}, function()
              	writefile(".tests/getcustomasset.txt", "success")
              	local contentId = getcustomasset(".tests/getcustomasset.txt")
              	assert(type(contentId) == "string", "Did not return a string")
              	assert(#contentId > 0, "Returned an empty string")
              	assert(string.match(contentId, "rbxasset://") == "rbxasset://", "Did not return an rbxasset url")
              end)
              
              test("gethiddenproperty", {}, function()
              	local fire = Instance.new("Fire")
              	local property, isHidden = gethiddenproperty(fire, "size_xml")
              	assert(property == 5, "Did not return the correct value")
              	assert(isHidden == true, "Did not return whether the property was hidden")
              end)
              
              test("sethiddenproperty", {}, function()
              	local fire = Instance.new("Fire")
              	local hidden = sethiddenproperty(fire, "size_xml", 10)
              	assert(hidden, "Did not return true for the hidden property")
              	assert(gethiddenproperty(fire, "size_xml") == 10, "Did not set the hidden property")
              end)
              
              test("gethui", {}, function()
              	assert(typeof(gethui()) == "Instance", "Did not return an Instance")
              end)
              
              test("getinstances", {}, function()
              	assert(getinstances()[1]:IsA("Instance"), "The first value is not an Instance")
              end)
              
              test("getnilinstances", {}, function()
              	assert(getnilinstances()[1]:IsA("Instance"), "The first value is not an Instance")
              	assert(getnilinstances()[1].Parent == nil, "The first value is not parented to nil")
              end)
              
              test("isscriptable", {}, function()
              	local fire = Instance.new("Fire")
              	assert(isscriptable(fire, "size_xml") == false, "Did not return false for a non-scriptable property (size_xml)")
              	assert(isscriptable(fire, "Size") == true, "Did not return true for a scriptable property (Size)")
              end)
              
              test("setscriptable", {}, function()
              	local fire = Instance.new("Fire")
              	local wasScriptable = setscriptable(fire, "size_xml", true)
              	assert(wasScriptable == false, "Did not return false for a non-scriptable property (size_xml)")
              	assert(isscriptable(fire, "size_xml") == true, "Did not set the scriptable property")
              	fire = Instance.new("Fire")
              	assert(isscriptable(fire, "size_xml") == false, "⚠️⚠️ setscriptable persists between unique instances ⚠️⚠️")
              end)
              
              test("setrbxclipboard", {})
              
              -- Metatable
              
              test("getrawmetatable", {}, function()
              	local metatable = { __metatable = "Locked!" }
              	local object = setmetatable({}, metatable)
              	assert(getrawmetatable(object) == metatable, "Did not return the metatable")
              end)
              
              test("hookmetamethod", {}, function()
              	local object = setmetatable({}, { __index = newcclosure(function() return false end), __metatable = "Locked!" })
              	local ref = hookmetamethod(object, "__index", function() return true end)
              	assert(object.test == true, "Failed to hook a metamethod and change the return value")
              	assert(ref() == false, "Did not return the original function")
              end)
              
              test("getnamecallmethod", {}, function()
              	local method
              	local ref
              	ref = hookmetamethod(game, "__namecall", function(...)
              		if not method then
              			method = getnamecallmethod()
              		end
              		return ref(...)
              	end)
              	game:GetService("Lighting")
              	assert(method == "GetService", "Did not get the correct method (GetService)")
              end)
              
              test("isreadonly", {}, function()
              	local object = {}
              	table.freeze(object)
              	assert(isreadonly(object), "Did not return true for a read-only table")
              end)
              
              test("setrawmetatable", {}, function()
              	local object = setmetatable({}, { __index = function() return false end, __metatable = "Locked!" })
              	local objectReturned = setrawmetatable(object, { __index = function() return true end })
              	assert(object, "Did not return the original object")
              	assert(object.test == true, "Failed to change the metatable")
              	if objectReturned then
              		return objectReturned == object and "Returned the original object" or "Did not return the original object"
              	end
              end)
              
              test("setreadonly", {}, function()
              	local object = { success = false }
              	table.freeze(object)
              	setreadonly(object, false)
              	object.success = true
              	assert(object.success, "Did not allow the table to be modified")
              end)
              
              -- Miscellaneous
              
              test("identifyexecutor", {"getexecutorname"}, function()
              	local name, version = identifyexecutor()
              	assert(type(name) == "string", "Did not return a string for the name")
              	return type(version) == "string" and "Returns version as a string" or "Does not return version"
              end)
              
              test("lz4compress", {}, function()
              	local raw = "Hello, world!"
              	local compressed = lz4compress(raw)
              	assert(type(compressed) == "string", "Compression did not return a string")
              	assert(lz4decompress(compressed, #raw) == raw, "Decompression did not return the original string")
              end)
              
              test("lz4decompress", {}, function()
              	local raw = "Hello, world!"
              	local compressed = lz4compress(raw)
              	assert(type(compressed) == "string", "Compression did not return a string")
              	assert(lz4decompress(compressed, #raw) == raw, "Decompression did not return the original string")
              end)
              
              test("messagebox", {})
              
              test("queue_on_teleport", {"queueonteleport"})
              
              test("request", {"http.request", "http_request"}, function()
              	local response = request({
              		Url = "https://httpbin.org/user-agent",
              		Method = "GET",
              	})
              	assert(type(response) == "table", "Response must be a table")
              	assert(response.StatusCode == 200, "Did not return a 200 status code")
              	local data = game:GetService("HttpService"):JSONDecode(response.Body)
              	assert(type(data) == "table" and type(data["user-agent"]) == "string", "Did not return a table with a user-agent key")
              	return "User-Agent: " .. data["user-agent"]
              end)
              
              test("setclipboard", {"toclipboard"})
              
              test("setfpscap", {}, function()
              	local renderStepped = game:GetService("RunService").RenderStepped
              	local function step()
              		renderStepped:Wait()
              		local sum = 0
              		for _ = 1, 5 do
              			sum += 1 / renderStepped:Wait()
              		end
              		return math.round(sum / 5)
              	end
              	setfpscap(60)
              	local step60 = step()
              	setfpscap(0)
              	local step0 = step()
              	return step60 .. "fps @60 • " .. step0 .. "fps @0"
              end)
              
              -- Scripts
              
              test("getgc", {}, function()
              	local gc = getgc()
              	assert(type(gc) == "table", "Did not return a table")
              	assert(#gc > 0, "Did not return a table with any values")
              end)
              
              test("getgenv", {}, function()
              	getgenv().__TEST_GLOBAL = true
              	assert(__TEST_GLOBAL, "Failed to set a global variable")
              	getgenv().__TEST_GLOBAL = nil
              end)
              
              test("getloadedmodules", {}, function()
              	local modules = getloadedmodules()
              	assert(type(modules) == "table", "Did not return a table")
              	assert(#modules > 0, "Did not return a table with any values")
              	assert(typeof(modules[1]) == "Instance", "First value is not an Instance")
              	assert(modules[1]:IsA("ModuleScript"), "First value is not a ModuleScript")
              end)
              
              test("getrenv", {}, function()
              	assert(_G ~= getrenv()._G, "The variable _G in the executor is identical to _G in the game")
              end)
              
              test("getrunningscripts", {}, function()
              	local scripts = getrunningscripts()
              	assert(type(scripts) == "table", "Did not return a table")
              	assert(#scripts > 0, "Did not return a table with any values")
              	assert(typeof(scripts[1]) == "Instance", "First value is not an Instance")
              	assert(scripts[1]:IsA("ModuleScript") or scripts[1]:IsA("LocalScript"), "First value is not a ModuleScript or LocalScript")
              end)
              
              test("getscriptbytecode", {"dumpstring"}, function()
              	local animate = game:GetService("Players").LocalPlayer.Character.Animate
              	local bytecode = getscriptbytecode(animate)
              	assert(type(bytecode) == "string", "Did not return a string for Character.Animate (a " .. animate.ClassName .. ")")
              end)
              
              test("getscripthash", {}, function()
              	local animate = game:GetService("Players").LocalPlayer.Character.Animate:Clone()
              	local hash = getscripthash(animate)
              	local source = animate.Source
              	animate.Source = "print('Hello, world!')"
              	task.defer(function()
              		animate.Source = source
              	end)
              	local newHash = getscripthash(animate)
              	assert(hash ~= newHash, "Did not return a different hash for a modified script")
              	assert(newHash == getscripthash(animate), "Did not return the same hash for a script with the same source")
              end)
              
              test("getscripts", {}, function()
              	local scripts = getscripts()
              	assert(type(scripts) == "table", "Did not return a table")
              	assert(#scripts > 0, "Did not return a table with any values")
              	assert(typeof(scripts[1]) == "Instance", "First value is not an Instance")
              	assert(scripts[1]:IsA("ModuleScript") or scripts[1]:IsA("LocalScript"), "First value is not a ModuleScript or LocalScript")
              end)
              
              test("getsenv", {}, function()
              	local animate = game:GetService("Players").LocalPlayer.Character.Animate
              	local env = getsenv(animate)
              	assert(type(env) == "table", "Did not return a table for Character.Animate (a " .. animate.ClassName .. ")")
              	assert(env.script == animate, "The script global is not identical to Character.Animate")
              end)
              
              test("getthreadidentity", {"getidentity", "getthreadcontext"}, function()
              	assert(type(getthreadidentity()) == "number", "Did not return a number")
              end)
              
              test("setthreadidentity", {"setidentity", "setthreadcontext"}, function()
              	setthreadidentity(3)
              	assert(getthreadidentity() == 3, "Did not set the thread identity")
              end)
              
              -- Drawing
              
              test("Drawing", {})
              
              test("Drawing.new", {}, function()
              	local drawing = Drawing.new("Square")
              	drawing.Visible = false
              	local canDestroy = pcall(function()
              		drawing:Destroy()
              	end)
              	assert(canDestroy, "Drawing:Destroy() should not throw an error")
              end)
              
              test("Drawing.Fonts", {}, function()
              	assert(Drawing.Fonts.UI == 0, "Did not return the correct id for UI")
              	assert(Drawing.Fonts.System == 1, "Did not return the correct id for System")
              	assert(Drawing.Fonts.Plex == 2, "Did not return the correct id for Plex")
              	assert(Drawing.Fonts.Monospace == 3, "Did not return the correct id for Monospace")
              end)
              
              test("isrenderobj", {}, function()
              	local drawing = Drawing.new("Image")
              	drawing.Visible = true
              	assert(isrenderobj(drawing) == true, "Did not return true for an Image")
              	assert(isrenderobj(newproxy()) == false, "Did not return false for a blank table")
              end)
              
              test("getrenderproperty", {}, function()
              	local drawing = Drawing.new("Image")
              	drawing.Visible = true
              	assert(type(getrenderproperty(drawing, "Visible")) == "boolean", "Did not return a boolean value for Image.Visible")
              	local success, result = pcall(function()
              		return getrenderproperty(drawing, "Color")
              	end)
              	if not success or not result then
              		return "Image.Color is not supported"
              	end
              end)
              
              test("setrenderproperty", {}, function()
              	local drawing = Drawing.new("Square")
              	drawing.Visible = true
              	setrenderproperty(drawing, "Visible", false)
              	assert(drawing.Visible == false, "Did not set the value for Square.Visible")
              end)
              
              test("cleardrawcache", {}, function()
              	cleardrawcache()
              end)
              
              -- WebSocket
              
              test("WebSocket", {})
              
              test("WebSocket.connect", {}, function()
              	local types = {
              		Send = "function",
              		Close = "function",
              		OnMessage = {"table", "userdata"},
              		OnClose = {"table", "userdata"},
              	}
              	local ws = WebSocket.connect("ws://echo.websocket.events")
              	assert(type(ws) == "table" or type(ws) == "userdata", "Did not return a table or userdata")
              	for k, v in pairs(types) do
              		if type(v) == "table" then
              			assert(table.find(v, type(ws[k])), "Did not return a " .. table.concat(v, ", ") .. " for " .. k .. " (a " .. type(ws[k]) .. ")")
              		else
              			assert(type(ws[k]) == v, "Did not return a " .. v .. " for " .. k .. " (a " .. type(ws[k]) .. ")")
              		end
              	end
              	ws:Close()
              end)

	            local rate = math.round(passes / (passes + fails) * 100)
                    local Unc = Instance.new("TextLabel")
                    Unc.Name = "Unc"
                    Unc.Parent = Page
                    Unc.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                    Unc.BackgroundTransparency = 1.000
                    Unc.Position = UDim2.new(0.113, 0,0.03, 0)
                    Unc.Size = UDim2.new(0, 110, 0, 20)
                    Unc.Font = Enum.Font.GothamSemibold
                    Unc.Text = "Unc : ".. rate
                    Unc.TextColor3 = Color3.fromRGB(225, 0, 0)
                    Unc.TextSize = 11.000
                    Unc.TextXAlignment = Enum.TextXAlignment.Left

                    local uitab = {}
                
                    function uitab:Tab(text,image)
                        local Image = image or 6023426915
                
                        local PageButton = Instance.new("TextButton")
                        PageButton.Name = "PageButton"
                        PageButton.Parent = ScrollPage
                        PageButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                        PageButton.BackgroundTransparency = 1.000
                        PageButton.BorderSizePixel = 0
                        PageButton.Position = UDim2.new(0.224000007, 0, 0.029787235, 0)
                        PageButton.Size = UDim2.new(0, 97, 0, 20)
                        PageButton.AutoButtonColor = false
                        PageButton.Font = Enum.Font.GothamSemibold
                        PageButton.Text = text
                        PageButton.TextColor3 = Color3.fromRGB(225, 225, 225)
                        PageButton.TextSize = 11.000
                        PageButton.TextXAlignment = Enum.TextXAlignment.Left
                        
                        local PageImage = Instance.new("ImageLabel")
                        PageImage.Name = "PageImage"
                        PageImage.Parent = PageButton
                        PageImage.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                        PageImage.BackgroundTransparency = 1.000
                        PageImage.Position = UDim2.new(0, -20, 0, 3)
                        PageImage.Size = UDim2.new(0, 15, 0, 15)
                        PageImage.Image = "rbxassetid://"..tostring(Image)
                
                        local MainTab = Instance.new("Frame")
                        MainTab.Name = "MainTab"
                        MainTab.Parent = TabFolder
                        MainTab.BackgroundColor3 = Color3.fromRGB(30, 28, 39)
                        MainTab.BorderSizePixel = 0
                        MainTab.Position = UDim2.new(0.208333328, 0, 0, 0)
                        MainTab.Size = UDim2.new(0, 475, 0, 350)
                        MainTab.Visible = false
                
                        local ScrollTab = Instance.new("ScrollingFrame")
                        ScrollTab.Name = "ScrollTab"
                        ScrollTab.Parent = MainTab
                        ScrollTab.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                        ScrollTab.BackgroundTransparency = 1.000
                        ScrollTab.BorderSizePixel = 0
                        ScrollTab.Position = UDim2.new(0, 0, 0.057, 0)
                        ScrollTab.Size = UDim2.new(0, 475, 0, 330)
                        ScrollTab.CanvasSize = UDim2.new(0, 0, 0, 0)
                        ScrollTab.ScrollBarThickness = 3
                
                        local TabList = Instance.new("UIListLayout")
                        TabList.Name = "TabList"
                        TabList.Parent = ScrollTab
                        TabList.SortOrder = Enum.SortOrder.LayoutOrder
                        TabList.Padding = UDim.new(0, 5)
                
                        local TabPadding = Instance.new("UIPadding")
                        TabPadding.Name = "TabPadding"
                        TabPadding.Parent = ScrollTab
                        TabPadding.PaddingLeft = UDim.new(0, 10)
                        TabPadding.PaddingTop = UDim.new(0, 10)
                
                        PageButton.MouseButton1Click:Connect(function()
                            currenttab = MainTab.Name
                            for i,v in next, TabFolder:GetChildren() do 
                                if v.Name == "MainTab" then
                                    v.Visible = false
                                end
                            end
                            MainTab.Visible = true
                
                            for i,v in next, ScrollPage:GetChildren() do 
                                if v:IsA("TextButton") then
                                    TweenService:Create(
                                        v,
                                        TweenInfo.new(0.3,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),
                                        {TextColor3 = Color3.fromRGB(225, 225, 225)}
                                    ):Play()
                                end
                                TweenService:Create(
                                    PageButton,
                                    TweenInfo.new(0.3,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),
                                    {TextColor3 = Color3.fromRGB(255,0,0)}
                                ):Play()
                            end
                        end)
                
                        if ff == false then
                            TweenService:Create(
                                PageButton,
                                TweenInfo.new(0.3,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),
                                {TextColor3 = Color3.fromRGB(255,0,0)}
                            ):Play()
                            for i,v in next, TabFolder:GetChildren() do 
                                if v.Name == "MainTab" then
                                    v.Visible = false
                                end
                                MainTab.Visible = true
                            end
                            ff = true
                        end
                
                        game:GetService("RunService").Stepped:Connect(function()
                            pcall(function()
                                ScrollPage.CanvasSize = UDim2.new(0,0,0,PageList.AbsoluteContentSize.Y + 10)
                                ScrollTab.CanvasSize = UDim2.new(0,0,0,TabList.AbsoluteContentSize.Y + 30)
                            end)
                        end)
                        
                        local main = {}
                        
                        function main:Button(text,callback)
                            local Button = Instance.new("TextButton")
                
                            Button.Name = "Button"
                            Button.Parent = ScrollTab
                            Button.BackgroundColor3 = Color3.fromRGB(50, 48, 59)
                            Button.BackgroundTransparency = 0.1
                            Button.BorderSizePixel = 0
                            Button.Size = UDim2.new(0, 455, 0, 30)
                            Button.AutoButtonColor = false
                            Button.Font = Enum.Font.Gotham
                            Button.Text = text
                            Button.TextColor3 = Color3.fromRGB(225, 225, 225)
                            Button.TextSize = 11.000
                            Button.TextWrapped = true
                            
                            local ButtonCorner = Instance.new("UICorner")
                            ButtonCorner.Name = "ButtonCorner"
                            ButtonCorner.CornerRadius = UDim.new(0, 5)
                            ButtonCorner.Parent = Button
                            
                            Button.MouseEnter:Connect(function()
                                TweenService:Create(
                                    Button,
                                    TweenInfo.new(0.4,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),
                                    {TextColor3 = Color3.fromRGB(255,0,0)}
                                ):Play()
                            end)
                            
                            Button.MouseLeave:Connect(function()
                                TweenService:Create(
                                    Button,
                                    TweenInfo.new(0.4,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),
                                    {TextColor3 = Color3.fromRGB(225, 225, 225)}
                                ):Play()
                            end)
                            
                            Button.MouseButton1Click:Connect(function()
                                callback()
                                Button.TextSize = 0
                                TweenService:Create(
                                    Button,
                                    TweenInfo.new(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.Out),
                                    {TextSize = 11}
                                ):Play()
                            end)
                        end
                        
                        function main:Toggle(text,config,callback)
                            local ToggleImage = Instance.new("Frame")
                            
                            local Toggle = Instance.new("TextButton")
                            Toggle.Name = "Toggle"
                            Toggle.Parent = ScrollTab
                            Toggle.BackgroundColor3 = Color3.fromRGB(50, 48, 59)
                            Toggle.BackgroundTransparency = 0.1
                            Toggle.BorderSizePixel = 0
                            Toggle.AutoButtonColor = false
                            Toggle.Size = UDim2.new(0, 455, 0, 30)
                            Toggle.Font = Enum.Font.SourceSans
                            Toggle.Text = ""
                            Toggle.TextColor3 = Color3.fromRGB(0, 0, 0)
                            Toggle.TextSize = 14.000
                            
                            local ToggleCorner = Instance.new("UICorner")
                            ToggleCorner.Name = "ToggleCorner"
                            ToggleCorner.CornerRadius = UDim.new(0, 5)
                            ToggleCorner.Parent = Toggle
                
                            local ToggleLabel = Instance.new("TextLabel")
                            ToggleLabel.Name = "ToggleLabel"
                            ToggleLabel.Parent = Toggle
                            ToggleLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                            ToggleLabel.BackgroundTransparency = 1.000
                            ToggleLabel.Position = UDim2.new(0, 13, 0, 0)
                            ToggleLabel.Size = UDim2.new(0, 410, 0, 30)
                            ToggleLabel.Font = Enum.Font.Gotham
                            ToggleLabel.Text = text
                            ToggleLabel.TextColor3 = Color3.fromRGB(225, 225, 225)
                            ToggleLabel.TextSize = 11.000
                            ToggleLabel.TextXAlignment = Enum.TextXAlignment.Left
                
                            ToggleImage.Name = "ToggleImage"
                            ToggleImage.Parent = Toggle
                            ToggleImage.BackgroundColor3 = Color3.fromRGB(70, 68, 79)
                            ToggleImage.Position = UDim2.new(0, 425, 0, 5)
                            ToggleImage.BorderSizePixel = 0
                            ToggleImage.Size = UDim2.new(0, 20, 0, 20)
                            local ToggleImageCorner = Instance.new("UICorner")
                            ToggleImageCorner.Name = "ToggleImageCorner"
                            ToggleImageCorner.CornerRadius = UDim.new(0, 5)
                            ToggleImageCorner.Parent = ToggleImage
                
                            local ToggleImage2 = Instance.new("Frame")
                            ToggleImage2.Name = "ToggleImage2"
                            ToggleImage2.Parent = ToggleImage
                            ToggleImage2.AnchorPoint = Vector2.new(0.5, 0.5)
                            ToggleImage2.BackgroundColor3 = Color3.fromRGB(255,0,0)
                            ToggleImage2.Position = UDim2.new(0, 10, 0, 10)
                            ToggleImage2.Visible = false
                
                            local ToggleImage2Corner = Instance.new("UICorner")
                            ToggleImage2Corner.Name = "ToggleImageCorner"
                            ToggleImage2Corner.CornerRadius = UDim.new(0, 5)
                            ToggleImage2Corner.Parent = ToggleImage2
                            
                            Toggle.MouseEnter:Connect(function()
                                TweenService:Create(
                                    ToggleLabel,
                                    TweenInfo.new(0.4,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),
                                    {TextColor3 = Color3.fromRGB(255,0,0)}
                                ):Play()
                            end)
                
                            Toggle.MouseLeave:Connect(function()
                                TweenService:Create(
                                    ToggleLabel,
                                    TweenInfo.new(0.4,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),
                                    {TextColor3 = Color3.fromRGB(225, 225, 225)}
                                ):Play()
                            end)
                            if config == nil then config = false end
                            local toggled = config or false
                            Toggle.MouseButton1Click:Connect(function()
                                if toggled == false then
                                    toggled = true
                                    ToggleImage2.Visible = true
                                    ToggleImage2:TweenSize(UDim2.new(0, 21, 0, 21),"In","Quad",0.1,true)
                                else
                                    toggled = false
                                    ToggleImage2:TweenSize(UDim2.new(0, 0, 0, 0),"In","Quad",0.1,true)
                                    wait(0.1)
                                    ToggleImage2.Visible = false
                                end
                                callback(toggled)
                            end)
                            
                            if config == true then
                                ToggleImage2.Visible = true
                                ToggleImage2:TweenSize(UDim2.new(0, 21, 0, 21),"In","Quad",0.1,true)
                                toggled = true
                                callback(toggled)
                            end
                        end
                
                        function main:Textbox(text,holder,disappear,callback)
                            local Textboxx = Instance.new("Frame")
                            local TextboxxCorner = Instance.new("UICorner")
                            local TextboxTitle = Instance.new("TextLabel")
                            local Textbox = Instance.new("TextBox")
                            local TextboxCorner = Instance.new("UICorner")
                
                            Textboxx.Name = "Textboxx"
                            Textboxx.Parent = ScrollTab
                            Textboxx.BackgroundColor3 = Color3.fromRGB(50, 48, 59)
                            Textboxx.Size = UDim2.new(0, 455, 0, 30)
                
                            TextboxxCorner.CornerRadius = UDim.new(0, 5)
                            TextboxxCorner.Name = "TextboxxCorner"
                            TextboxxCorner.Parent = Textboxx
                
                            TextboxTitle.Name = "TextboxTitle"
                            TextboxTitle.Parent = Textboxx
                            TextboxTitle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                            TextboxTitle.BackgroundTransparency = 1.000
                            TextboxTitle.Position = UDim2.new(0, 15, 0, 0)
                            TextboxTitle.Size = UDim2.new(0, 300, 0, 30)
                            TextboxTitle.Font = Enum.Font.Gotham
                            TextboxTitle.Text = text
                            TextboxTitle.TextColor3 = Color3.fromRGB(225, 225, 225)
                            TextboxTitle.TextSize = 11.000
                            TextboxTitle.TextXAlignment = Enum.TextXAlignment.Left
                
                            Textbox.Name = "Textbox"
                            Textbox.Parent = Textboxx
                            Textbox.BackgroundColor3 = Color3.fromRGB(30, 28, 39)
                            Textbox.Position = UDim2.new(0, 310, 0, 5)
                            Textbox.Size = UDim2.new(0, 140, 0, 20)
                            Textbox.Font = Enum.Font.Gotham
                            Textbox.Text = holder
                            Textbox.TextColor3 = Color3.fromRGB(225, 225, 225)
                            Textbox.TextSize = 11.000
                
                            Textbox.FocusLost:Connect(function()
                                if #Textbox.Text > 0 then
                                    callback(Textbox.Text)
                                end
                                if disappear then
                                    Textbox.Text = ""
                                else
                                    Textbox.Text = holder
                                end
                            end)
                
                            TextboxCorner.Name = "TextboxCorner"
                            TextboxCorner.CornerRadius = UDim.new(0, 5)
                            TextboxCorner.Parent = Textbox
                        end
                
                        function main:Dropdown(text,table,callback)
                            local Dropdown = Instance.new("Frame")
                            local UICorner = Instance.new("UICorner")
                            local DropButton = Instance.new("TextButton")
                            local Droptitle = Instance.new("TextLabel")
                            local DropScroll = Instance.new("ScrollingFrame")
                            local DropdownList = Instance.new("UIListLayout")
                            local DropdownPadding = Instance.new("UIPadding")
                            local DropImage = Instance.new("ImageLabel")
                            
                            Dropdown.Name = "Dropdown"
                            Dropdown.Parent = ScrollTab
                            Dropdown.Active = true
                            Dropdown.BackgroundColor3 = Color3.fromRGB(50, 48, 59)
                            Dropdown.ClipsDescendants = true
                            Dropdown.Size = UDim2.new(0, 455, 0, 30)
                            
                            UICorner.CornerRadius = UDim.new(0, 5)
                            UICorner.Parent = Dropdown
                            
                            DropButton.Name = "DropButton"
                            DropButton.Parent = Dropdown
                            DropButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                            DropButton.BackgroundTransparency = 1.000
                            DropButton.Size = UDim2.new(0, 455, 0, 30)
                            DropButton.Font = Enum.Font.SourceSans
                            DropButton.Text = ""
                            DropButton.TextColor3 = Color3.fromRGB(0, 0, 0)
                            DropButton.TextSize = 14.000
                            
                            Droptitle.Name = "Droptitle"
                            Droptitle.Parent = Dropdown
                            Droptitle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                            Droptitle.BackgroundTransparency = 1.000
                            Droptitle.Position = UDim2.new(0.0281690136, 0, 0, 0)
                            Droptitle.Size = UDim2.new(0, 410, 0, 30)
                            Droptitle.Font = Enum.Font.Gotham
                            Droptitle.Text = text.." : "
                            Droptitle.TextColor3 = Color3.fromRGB(225, 225, 225)
                            Droptitle.TextSize = 11.000
                            Droptitle.TextXAlignment = Enum.TextXAlignment.Left
                
                            DropImage.Name = "DropImage"
                            DropImage.Parent = Dropdown
                            DropImage.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                            DropImage.BackgroundTransparency = 1.000
                            DropImage.Position = UDim2.new(0, 425, 0, 5)
                            DropImage.Rotation = 0
                            DropImage.Size = UDim2.new(0, 20, 0, 20)
                            DropImage.Image = "rbxassetid://5012539403"
                            
                            DropScroll.Name = "DropScroll"
                            DropScroll.Parent = Droptitle
                            DropScroll.Active = true
                            DropScroll.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                            DropScroll.BackgroundTransparency = 1.000
                            DropScroll.BorderSizePixel = 0
                            DropScroll.Position = UDim2.new(-0.0317460336, 0, 1, 0)
                            DropScroll.Size = UDim2.new(0, 455, 0, 70)
                            DropScroll.CanvasSize = UDim2.new(0, 0, 0, 2)
                            DropScroll.ScrollBarThickness = 2
                            
                            DropdownList.Name = "DropdownList"
                            DropdownList.Parent = DropScroll
                            DropdownList.SortOrder = Enum.SortOrder.LayoutOrder
                            DropdownList.Padding = UDim.new(0, 5)
                            
                            DropdownPadding.Name = "DropdownPadding"
                            DropdownPadding.Parent = DropScroll
                            DropdownPadding.PaddingTop = UDim.new(0, 5)
                
                            local isdropping = false
                
                            for i,v in next,table do
                                local DropButton2 = Instance.new("TextButton")
                
                                DropButton2.Name = "DropButton2"
                                DropButton2.Parent = DropScroll
                                DropButton2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                                DropButton2.BackgroundTransparency = 1.000
                                DropButton2.Size = UDim2.new(0, 455, 0, 30)
                                DropButton2.AutoButtonColor = false
                                DropButton2.Font = Enum.Font.Gotham
                                DropButton2.TextColor3 = Color3.fromRGB(225, 225, 225)
                                DropButton2.TextSize = 11.000
                                DropButton2.Text = tostring(v)
                
                                DropButton2.MouseEnter:Connect(function()
                                    TweenService:Create(
                                        DropButton2,
                                        TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                                        {TextColor3 = Color3.fromRGB(255,0,0)}
                                    ):Play()
                                end)
                                DropButton2.MouseLeave:Connect(function()
                                    TweenService:Create(
                                        DropButton2,
                                        TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                                        {TextColor3 = Color3.fromRGB(225, 225, 225)}
                                    ):Play()
                                end)
                
                                DropButton2.MouseButton1Click:Connect(function()
                                    TweenService:Create(
                                        Dropdown,
                                        TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                                        {Size = UDim2.new(0, 455, 0, 30)}
                                    ):Play()
                                    TweenService:Create(
                                        DropImage,
                                        TweenInfo.new(0.3, Enum.EasingStyle.Linear, Enum.EasingDirection.Out),
                                        {Rotation = 0}
                                    ):Play()
                                    Droptitle.Text =  text.." : "..tostring(v)
                                    callback(v)
                                    isdropping = not isdropping
                                    DropScroll.CanvasSize = UDim2.new(0,0,0,DropdownList.AbsoluteContentSize.Y + 10)
                                end)
                            end
                
                            DropButton.MouseButton1Click:Connect(function()
                                if isdropping == false then
                                    isdropping = true
                                    TweenService:Create(
                                        Dropdown,
                                        TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                                        {Size = UDim2.new(0, 455, 0, 100)}
                                    ):Play()
                                    TweenService:Create(
                                        DropImage,
                                        TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                                        {Rotation = -180}
                                    ):Play()
                                    DropScroll.CanvasSize = UDim2.new(0,0,0,DropdownList.AbsoluteContentSize.Y + 10)
                                else
                                    isdropping = false
                                    TweenService:Create(
                                        Dropdown,
                                        TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                                        {Size = UDim2.new(0, 455, 0, 30)}
                                    ):Play()
                                    TweenService:Create(
                                        DropImage,
                                        TweenInfo.new(0.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                                        {Rotation = 0}
                                    ):Play()
                                    DropScroll.CanvasSize = UDim2.new(0,0,0,DropdownList.AbsoluteContentSize.Y + 10)
                                end
                            end)
                            DropScroll.CanvasSize = UDim2.new(0,0,0,DropdownList.AbsoluteContentSize.Y + 10)
                
                            local drop = {}
                
                            function drop:Clear()
                                Droptitle.Text = tostring(text).." :"
                                TweenService:Create(
                                    Dropdown,
                                    TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                                    {Size = UDim2.new(0, 455, 0, 30)} 
                                ):Play()
                                isdropping = false
                                for i, v in next, DropScroll:GetChildren() do
                                    if v:IsA("TextButton") then
                                        v:Destroy()
                                    end
                                end
                            end
                            function drop:Add(t)
                                local DropButton2 = Instance.new("TextButton")
                
                                DropButton2.Name = "DropButton2"
                                DropButton2.Parent = DropScroll
                                DropButton2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                                DropButton2.BackgroundTransparency = 1.000
                                DropButton2.Size = UDim2.new(0, 455, 0, 30)
                                DropButton2.AutoButtonColor = false
                                DropButton2.Font = Enum.Font.Gotham
                                DropButton2.TextColor3 = Color3.fromRGB(225, 225, 225)
                                DropButton2.TextSize = 11.000
                                DropButton2.Text = tostring(t)
                
                                DropButton2.MouseButton1Click:Connect(function()
                                    TweenService:Create(
                                        Dropdown,
                                        TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
                                        {Size = UDim2.new(0, 455, 0, 30)}
                                    ):Play()
                                    TweenService:Create(
                                        DropImage,
                                        TweenInfo.new(0.3, Enum.EasingStyle.Linear, Enum.EasingDirection.Out),
                                        {Rotation = 0}
                                    ):Play()
                                    Droptitle.Text =  text.." : "..tostring(t)
                                    callback(t)
                                    isdropping = not isdropping
                                    DropScroll.CanvasSize = UDim2.new(0,0,0,DropdownList.AbsoluteContentSize.Y + 10)
                                end)
                            end
                            return drop
                        end
                
                        function main:Slider(text,min,max,set,callback)
                            set = (math.clamp(set,min,max))
                            if set > max then set = max end
                
                            local Slider = Instance.new("Frame")
                            local UICorner = Instance.new("UICorner")
                            local SliderTitle = Instance.new("TextLabel")
                            local SliderValue = Instance.new("TextLabel")
                            local SliderButton = Instance.new("TextButton")
                            local Bar1 = Instance.new("Frame")
                            local Bar = Instance.new("Frame")
                            local UICorner_2 = Instance.new("UICorner")
                            local CircleBar = Instance.new("Frame")
                            local UICorner_3 = Instance.new("UICorner")
                            local UICorner_4 = Instance.new("UICorner")
                
                            Slider.Name = "Slider"
                            Slider.Parent = ScrollTab
                            Slider.BackgroundColor3 = Color3.fromRGB(50, 48, 59)
                            Slider.Size = UDim2.new(0, 455, 0, 40)
                
                            UICorner.CornerRadius = UDim.new(0, 5)
                            UICorner.Parent = Slider
                
                            SliderTitle.Name = "SliderTitle"
                            SliderTitle.Parent = Slider
                            SliderTitle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                            SliderTitle.BackgroundTransparency = 1.000
                            SliderTitle.Position = UDim2.new(0.0283286124, 0, 0, 0)
                            SliderTitle.Size = UDim2.new(0, 290, 0, 20)
                            SliderTitle.Font = Enum.Font.Gotham
                            SliderTitle.Text = text
                            SliderTitle.TextColor3 = Color3.fromRGB(225, 225, 225)
                            SliderTitle.TextSize = 11.000
                            SliderTitle.TextXAlignment = Enum.TextXAlignment.Left
                
                            SliderValue.Name = "SliderValue"
                            SliderValue.Parent = Slider
                            SliderValue.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                            SliderValue.BackgroundTransparency = 1.000
                            SliderValue.Position = UDim2.new(0.887778878, 0, 0, 0)
                            SliderValue.Size = UDim2.new(0, 40, 0, 20)
                            SliderValue.Font = Enum.Font.Gotham
                            SliderValue.Text =  tostring(set and math.floor( (set / max) * (max - min) + min) or 0)
                            SliderValue.TextColor3 = Color3.fromRGB(225, 225, 225)
                            SliderValue.TextSize = 11.000
                
                            SliderButton.Name = "SliderButton"
                            SliderButton.Parent = Slider
                            SliderButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                            SliderButton.BackgroundTransparency = 1.000
                            SliderButton.Position = UDim2.new(0, 10, 0, 25)
                            SliderButton.Size = UDim2.new(0, 435, 0, 5)
                            SliderButton.AutoButtonColor = false
                            SliderButton.Font = Enum.Font.SourceSans
                            SliderButton.Text = ""
                            SliderButton.TextColor3 = Color3.fromRGB(0, 0, 0)
                            SliderButton.TextSize = 14.000
                
                            Bar1.Name = "Bar1"
                            Bar1.Parent = SliderButton
                            Bar1.BackgroundColor3 = Color3.fromRGB(30, 28, 39)
                            Bar1.Size = UDim2.new(0, 435, 0, 5)
                
                            Bar.Name = "Bar"
                            Bar.Parent = Bar1
                            Bar.BackgroundColor3 = Color3.fromRGB(255,0,0)
                            Bar.Size = UDim2.new(set/max, 0, 0, 5)
                
                            UICorner_2.CornerRadius = UDim.new(0, 100)
                            UICorner_2.Parent = Bar
                
                            CircleBar.Name = "CircleBar"
                            CircleBar.Parent = Bar
                            CircleBar.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                            CircleBar.Position = UDim2.new(1, -2, 0, -2)
                            CircleBar.AnchorPoint = Vector2.new(0, 0.1)
                            CircleBar.Size = UDim2.new(0, 10, 0, 10)
                
                            UICorner_3.CornerRadius = UDim.new(0, 100)
                            UICorner_3.Parent = CircleBar
                
                            UICorner_4.CornerRadius = UDim.new(0, 100)
                            UICorner_4.Parent = Bar1
                            
                            local mouse = game.Players.LocalPlayer:GetMouse()
                            local uis = game:GetService("UserInputService")
                
                            if Value == nil then
                                Value = set
                                pcall(function()
                                    callback(Value)
                                end)
                            end
                            
                            SliderButton.MouseButton1Down:Connect(function()
                                Value = math.floor((((tonumber(max) - tonumber(min)) / 435) * Bar.AbsoluteSize.X) + tonumber(min)) or 0
                                pcall(function()
                                    callback(Value)
                                end)
                                Bar.Size = UDim2.new(0, math.clamp(mouse.X - Bar.AbsolutePosition.X, 0, 435), 0, 5)
                                CircleBar.Position = UDim2.new(0, math.clamp(mouse.X - Bar.AbsolutePosition.X - 2, 0, 425), 0, -2)
                                moveconnection = mouse.Move:Connect(function()
                                    SliderValue.Text = Value
                                    Value = math.floor((((tonumber(max) - tonumber(min)) / 435) * Bar.AbsoluteSize.X) + tonumber(min))
                                    pcall(function()
                                        callback(Value)
                                    end)
                                    Bar.Size = UDim2.new(0, math.clamp(mouse.X - Bar.AbsolutePosition.X, 0, 435), 0, 5)
                                    CircleBar.Position = UDim2.new(0, math.clamp(mouse.X - Bar.AbsolutePosition.X - 2, 0, 425), 0, -2)
                                end)
                                releaseconnection = uis.InputEnded:Connect(function(Mouse)
                                    if Mouse.UserInputType == Enum.UserInputType.MouseButton1 then
                                        Value = math.floor((((tonumber(max) - tonumber(min)) / 435) * Bar.AbsoluteSize.X) + tonumber(min))
                                        pcall(function()
                                            callback(Value)
                                        end)
                                        Bar.Size = UDim2.new(0, math.clamp(mouse.X - Bar.AbsolutePosition.X, 0, 435), 0, 5)
                                        CircleBar.Position = UDim2.new(0, math.clamp(mouse.X - Bar.AbsolutePosition.X - 2, 0, 425), 0, -2)
                                        moveconnection:Disconnect()
                                        releaseconnection:Disconnect()
                                    end
                                end)
                            end)
                            releaseconnection = uis.InputEnded:Connect(function(Mouse)
                                if Mouse.UserInputType == Enum.UserInputType.MouseButton1 then
                                    Value = math.floor((((tonumber(max) - tonumber(min)) / 435) * Bar.AbsoluteSize.X) + tonumber(min))
                                    SliderValue.Text = Value
                                end
                            end)
                        end
                        function main:Seperator(text)
                            local Seperator = Instance.new("Frame")
                            local Sep1 = Instance.new("Frame")
                            local SepLabel = Instance.new("TextLabel")
                            local Sep2 = Instance.new("Frame")
                
                            Seperator.Name = "Seperator"
                            Seperator.Parent = ScrollTab
                            Seperator.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                            Seperator.BackgroundTransparency = 1.000
                            Seperator.ClipsDescendants = true
                            Seperator.Size = UDim2.new(0, 455, 0, 20)
                
                            Sep1.Name = "Sep1"
                            Sep1.Parent = Seperator
                            Sep1.BackgroundColor3 = Color3.fromRGB(255,0,0)
                            Sep1.BorderSizePixel = 0
                            Sep1.Position = UDim2.new(0, 0, 0, 10)
                            Sep1.Size = UDim2.new(0, 150, 0, 1)
                
                            SepLabel.Name = "SepLabel"
                            SepLabel.Parent = Seperator
                            SepLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                            SepLabel.BackgroundTransparency = 1.000
                            SepLabel.Position = UDim2.new(0, 95, 0, 0)
                            SepLabel.Size = UDim2.new(0, 255, 0, 20)
                            SepLabel.Font = Enum.Font.Gotham
                            SepLabel.Text = text
                            SepLabel.TextColor3 = Color3.fromRGB(225,225,225)
                            SepLabel.TextSize = 11.000
                
                            Sep2.Name = "Sep2"
                            Sep2.Parent = Seperator
                            Sep2.BackgroundColor3 = Color3.fromRGB(255,0,0)
                            Sep2.BorderSizePixel = 0
                            Sep2.Position = UDim2.new(0, 305, 0, 10)
                            Sep2.Size = UDim2.new(0, 150, 0, 1)
                        end
                        function main:Line()
                            local Line = Instance.new("Frame")
                            local Linee = Instance.new("Frame")
                
                            Line.Name = "Line"
                            Line.Parent = ScrollTab
                            Line.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                            Line.BackgroundTransparency = 1.000
                            Line.ClipsDescendants = true
                            Line.Size = UDim2.new(0, 455, 0, 20)
                
                            Linee.Name = "Linee"
                            Linee.Parent = Line
                            Linee.BackgroundColor3 = Color3.fromRGB(255,0,0)
                            Linee.BorderSizePixel = 0
                            Linee.Position = UDim2.new(0, 0, 0, 10)
                            Linee.Size = UDim2.new(0, 455, 0, 1)
                        end
                        function main:Label(text)
                            local Label = Instance.new("TextLabel")
                            local PaddingLabel = Instance.new("UIPadding")
                            local labell = {}
                    
                            Label.Name = "Label"
                            Label.Parent = ScrollTab
                            Label.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                            Label.BackgroundTransparency = 1.000
                            Label.Size = UDim2.new(0, 455, 0, 20)
                            Label.Font = Enum.Font.Gotham
                            Label.TextColor3 = Color3.fromRGB(225, 225, 225)
                            Label.TextSize = 11.000
                            Label.Text = text
                            Label.TextXAlignment = Enum.TextXAlignment.Left
                
                            PaddingLabel.PaddingLeft = UDim.new(0,10)
                            PaddingLabel.Parent = Label
                            PaddingLabel.Name = "PaddingLabel"
                    
                        function labell:Set(newtext)
                            Label.Text = newtext
                        end
                    return labell
                end
            return main
        end
    return uitab
end
return library
